// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /auth/login)
	Login(ctx echo.Context) error

	// (POST /auth/signup)
	SignUp(ctx echo.Context) error

	// (GET /auth/whoami)
	AuthTest(ctx echo.Context, params AuthTestParams) error
	// Returns all posts
	// (GET /posts)
	FindPosts(ctx echo.Context, params FindPostsParams) error
	// Creates a new post
	// (POST /posts)
	AddPost(ctx echo.Context) error
	// Deletes a post by ID
	// (DELETE /posts/{id})
	DeletePostByID(ctx echo.Context, id int32) error
	// Returns a post by ID
	// (GET /posts/{id})
	FindPostByID(ctx echo.Context, id int32) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Login(ctx)
	return err
}

// SignUp converts echo context to params.
func (w *ServerInterfaceWrapper) SignUp(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SignUp(ctx)
	return err
}

// AuthTest converts echo context to params.
func (w *ServerInterfaceWrapper) AuthTest(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthTestParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-auth" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-auth")]; found {
		var XAuth string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-auth, got %d", n))
		}

		err = runtime.BindStyledParameter("simple", false, "x-auth", valueList[0], &XAuth)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-auth: %s", err))
		}

		params.XAuth = XAuth
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-auth is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthTest(ctx, params)
	return err
}

// FindPosts converts echo context to params.
func (w *ServerInterfaceWrapper) FindPosts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPostsParams
	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindPosts(ctx, params)
	return err
}

// AddPost converts echo context to params.
func (w *ServerInterfaceWrapper) AddPost(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddPost(ctx)
	return err
}

// DeletePostByID converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePostByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int32

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeletePostByID(ctx, id)
	return err
}

// FindPostByID converts echo context to params.
func (w *ServerInterfaceWrapper) FindPostByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int32

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FindPostByID(ctx, id)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/auth/login", wrapper.Login)
	router.POST("/auth/signup", wrapper.SignUp)
	router.GET("/auth/whoami", wrapper.AuthTest)
	router.GET("/posts", wrapper.FindPosts)
	router.POST("/posts", wrapper.AddPost)
	router.DELETE("/posts/:id", wrapper.DeletePostByID)
	router.GET("/posts/:id", wrapper.FindPostByID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RX0W/bthP+Vwj+fo+q5abFMPhpadwOHro2WBrsoQgGRjpZ3ERSvTvF9QL97wNJybEt",
	"OW7atQ2wp8QidffdfR+/o25l5kztLFgmObuVCFQ7SxB+XFrVcOlQ/w35S0SH/mEOlKGuWTsrZ/I0y4BI",
	"sPsLrNAkjCbSdikcCm1vVKVz2baJpKwEo0LQTaAaXQ3IOubKXA7D8GGzCGuJLBwaxXImteVnJzKRvK4h",
	"/oQloGwTaYBILQ8G6pc3rxKjtssAEeFDoxFyOXsvu4T99qs2kW9gde6Ix4BbBsvDlGdxQbhCcAmi9m8f",
	"TxyDdRkvCUZaVSuilcN8mNLvF/1yIhSLChSx+FFkpUKVMeB2HzeBBrCSzdofmbOFRjNM9mtDLEgZEIrE",
	"VqhPCt8QoFUGDtTglxJxafWHBhKRKWsd+xrsJ5C3CZ1sIxjU41vcM6qq6m0hZ+9v5f8RCjmT/0vvjkXa",
	"iTftJdAm+4zoMS4CeKHzPQFsq/iH5yMq3itH5/Kq9WDHxfC5qQ8coHt4iUH9Yh/Wbz5Kh/bd34S9Cm4A",
	"WYOa1xe+sbGMa1AIeNpweffrVQ/3l9/fyc5DfKK4epe4ZK5l6wNrW7j+TKosUAtG6UrOpKo1gzI/0Uot",
	"l4AT7WQiY6XyIj4Tp+cL8Q6U8YCx6iLP0nTrnTbZN0DBK80MKLLKWRCqrmUiK52BpdDFLsdprbISxMlk",
	"uhOdZmm6Wq0mKixPHC7T7l1KXy/OXr65ePnkZDKdlGwqn5wBDb0tLgBvdAZjENOwJfXt0Vz5LT+7gO/0",
	"fCETeQNIEfnTyXQy9TFdDVbVWs7ks/DIHxYuAy2pHwBp5ZbaBul152W3Ba/9ci8Gr03lFxZ5vySjIID4",
	"hcvXe56p6rrSWXgj/ZNcSBMP3P3G92CXebhpXAVN7daaoc69qbMT1VZtMQxjAyHu1gw9mU4fVPF9BhQc",
	"YARUJICaMIujRAvVVPyvJY4zeyRzY+FjDRlDLqDf0yadbEgvbVMf1k2GoBiEhdW4eC700l7WX6CeI2Z+",
	"qJ0+r2jqbWDHOH761Tl+04ERsWv546F5VTpltI+9hBGWEbhBK7IG0R+cUaa977+DMKNqhcoAA1KYx7ux",
	"fDliBdfxvim94XsLBJWHoJ3VfnzicQ1YS7a6sG8GV9/h1J5td6RN5POoorFQG2zp8Eq+PVBDy7ZH6Xt/",
	"dfBM+RNIBzn6LXBEQlVVuCuQKNCZMONpTQz+X8WbmS9KRUL1N/8Bm6+0zc9DviN0ErAoNBKHpN5To1h6",
	"Yj80gOs7Xl1REPAOr4WqaIfYo1ccf3nbRWHUR20aI2xjrgH93QaBmorpKKBKG/3FeL5UeprB0DENdvfW",
	"PrtCVOsxTUbyezzf22MSSY0xCtdjEg0fKaNz5Sw4JAkVHDxIS9soZnYIEzFvInq/B8GHdCvIh66UBxl/",
	"vQEUWRm24rw7DSrP/Z8N8m86iA6BC/18jAoZ0i7vrC+91XkbpVIBj3zexOf+bdJ2WcVvJnGtCHLhonoW",
	"c0GNL2tEK/Pwuu/Zi/Vifsz4FnNvM73pdZA6j/F37zuLCV9Ph+fY59jL82HxAUmEkT8mSucbUiIba7GY",
	"e3z3D7E96jaMBl7GR9XDSSuAs/KbcTb97x7rfVqjBuKtB296qna+1yuXqap0xLNn0+lT2V61/wQAAP//",
	"AJvgqucUAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
